// Automatically generated file
// Do not modify


// BloomBlend.ush
static const char BloomBlend_ush[] = "BloomBlend.ush\x00"
"\n\n\n\n\n\n\nuniform sampler2D BlurTex;\nuniform sampler2D OrigTex;\n"
"uniform sampler2D DepthTex;\n\nvoid VertexShaderMain()\n{\n"
"gl_TexCoord[0]=gl_MultiTexCoord0;\ngl_Position=ftransform();\n}\n\n"
"#define BLOOM_SCALE 4.0\n\nvoid PixelShaderMain()\n{\n"
"vec2 TexCoord=gl_TexCoord[0].st;\nvec4 Blur=texture2D(BlurTex,TexCoord);\n"
"vec3 Orig=texture2D(OrigTex,TexCoord).rgb;\nvec4 c;\n\n\n\n\n\n"
"c=vec4(Orig+Blur.rgb*Blur.a*BLOOM_SCALE,1.0);\n\n\n\ngl_FragColor=c;\n\n\n"
"float f=texture2D(DepthTex,TexCoord).r;\ngl_FragDepth=f;\n\n#ifdef SHOW_DEPTH\n"
"f=2.0 /(1000.0-f*1000.0);\ngl_FragColor=vec4(f,f,f,1.0);\n#endif\n}\n";


// BloomGather.ush
static const char BloomGather_ush[] = "BloomGather.ush\x00"
"\n\n\n\nuniform sampler2D tex;\n\nvoid VertexShaderMain()\n{\n"
"gl_TexCoord[0]=gl_MultiTexCoord0;\ngl_Position=ftransform();\n}\n\n\n"
"void PixelShaderMain()\n{\nvec3 c;\nvec2 TexCoord=gl_TexCoord[0].st;\n"
"c=texture2D(tex,TexCoord).rgb;\nfloat m=max(c.r,c.g);\nm=max(m,c.b);\n#if 0\n"
"if(m <=1.0)m=0.0;\nc*=0.5;\n#else\nm=max(m-1.0,0.0);\n#endif\n"
"gl_FragColor=vec4(c,m);\n}\n";


// BloomPass.ush
static const char BloomPass_ush[] = "BloomPass.ush\x00"
"\n\n\n\nuniform sampler2D Tex;\nuniform vec2 Step;\n\nvoid VertexShaderMain()\n"
"{\ngl_TexCoord[0]=gl_MultiTexCoord0;\ngl_Position=ftransform();\n}\n\n\n\n\n\n"
"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#define W0 6.0\n#define W1 10.8\n"
"#define W2 6.4\n#define W3 2.2\n\n#define OF1 1.47\n#define OF2 3.35\n"
"#define OF3 5.32\n\n\n#define W_SUM W0+2.0*(W1+W2+W3)\n\n"
"void PixelShaderMain()\n{\nvec4 c;\nvec2 TexCoord=gl_TexCoord[0].st;\n"
"c=texture2D(Tex,TexCoord)*W0;\nc+=texture2D(Tex,TexCoord-Step*OF1)*W1;\n"
"c+=texture2D(Tex,TexCoord+Step*OF1)*W1;\n"
"c+=texture2D(Tex,TexCoord-Step*OF2)*W2;\n"
"c+=texture2D(Tex,TexCoord+Step*OF2)*W2;\n"
"c+=texture2D(Tex,TexCoord-Step*OF3)*W3;\n"
"c+=texture2D(Tex,TexCoord+Step*OF3)*W3;\nc*=1.0 /(W_SUM);\n\ngl_FragColor=c;\n"
"}\n";


// Generic.ush
static const char Generic_ush[] = "Generic.ush\x00"
"\n\n\n\n#define SPECULAR\n\n#ifndef TEXTURING\n#define TEXTURING 1\n#endif\n\n"
"#define PIXEL_LIGHT_DIR\n#define PIXEL_HALF_VEC\n\n\n"
"varying vec4 diffuse,ambient,specular;\nvarying vec3 normal;\n\n"
"#ifndef PIXEL_LIGHT_DIR\nvarying vec3 lightDir;\n#endif\n"
"varying vec3 position;\n#ifndef PIXEL_HALF_VEC\nvarying vec3 halfVector;\n"
"#endif\n\n\n#if TEXTURING\nuniform sampler2D tex;\n#endif\n\n"
"uniform bool useLighting;\nuniform vec3 eyeLocation;\n\n\n"
"void VertexShaderMain()\n{\n\nnormal=normalize(gl_NormalMatrix*gl_Normal);\n"
"position=(gl_ModelViewMatrix*gl_Vertex).xyz;\n\n#ifndef PIXEL_LIGHT_DIR\n"
"lightDir=gl_LightSource[0].position.xyz-position;\n#endif\n"
"#ifndef PIXEL_HALF_VEC\nhalfVector=gl_LightSource[0].halfVector.xyz;\n#endif\n"
"\nif(useLighting)\n{\n\ndiffuse=gl_Color*gl_LightSource[0].diffuse;\n"
"ambient=gl_Color*(gl_LightSource[0].ambient+gl_LightModel.ambient);\n"
"specular=gl_FrontMaterial.specular*gl_LightSource[0].specular;\n}\nelse\n{\n"
"diffuse=vec4(0.0);\nambient=gl_Color;\nspecular=vec4(0.0);\n}\n"
"gl_TexCoord[0]=gl_MultiTexCoord0;\ngl_Position=ftransform();\n}\n\n\n"
"void PixelShaderMain()\n{\n#ifdef PIXEL_LIGHT_DIR\n"
"vec3 lightDir=gl_LightSource[0].position.xyz-position;\n#endif\n"
"vec3 nLightDir=normalize(lightDir);\nvec3 n=normalize(normal);\n"
"float NdotL=max(dot(n,nLightDir),0.0);\n\nvec4 color=ambient+diffuse*NdotL;\n\n"
"#if TEXTURING\nvec4 texColor=texture2D(tex,gl_TexCoord[0].st);\n"
"color.rgb*=texColor.rgb;\ncolor.a=texColor.a;\n#endif\n\n#ifdef SPECULAR\n\n\n"
"\nfloat specularScale=0.5;\n#ifdef PIXEL_HALF_VEC\n"
"vec3 eyeDir=normalize(eyeLocation-position);\n"
"vec3 halfVector=nLightDir+eyeDir;\n#endif\nvec3 halfV=normalize(halfVector);\n"
"float NdotHV=max(dot(n,halfV),0.0);\n"
"color.rgb+=pow(NdotHV,gl_FrontMaterial.shininess)*specular.rgb*specularScale;\n"
"#endif\n\n#ifdef NORMALMAP\ngl_FragColor=vec4(n,1.0);\n#else\n"
"gl_FragColor=color;\n#endif\n}\n";


// Normal.ush
static const char Normal_ush[] = "Normal.ush\x00"
"\n\n\n\n\n\n\n\n\n#define SPECULAR\n\n#ifndef DIFFUSE\n#define DIFFUSE 0\n"
"#endif\n\n#ifndef CUBE\n#define CUBE 0\n#endif\n\n#ifdef SHOW_BUMP\n"
"#undef EMISSIVE\n#endif\n\n#ifndef EMISSIVE\n#define EMISSIVE 0\n#endif\n\n\n"
"#undef CUBE\n#define CUBE 1\n\n#if defined(CUBE)|| defined(WORLDNORMAL)\n"
"#define NEEDS_TANGENT_TO_WORLD\n#endif\n\n\n"
"varying vec4 diffuse,ambient,specular;\n"
"varying vec3 tangentLightDir,tangentEye;\n#ifdef NEEDS_TANGENT_TO_WORLD\n"
"varying mat3 tangentToWorld;\n#endif\nvarying vec3 tmp;\n\n\n"
"attribute vec4 normal;\nattribute vec3 tangent;\n\n\n\n\n"
"uniform sampler2D diffTex;\nuniform sampler2D normTex;\n"
"uniform sampler2D specTex;\nuniform sampler2D spPowTex;\n"
"uniform sampler2D opacTex;\nuniform sampler2D emisTex;\n"
"uniform samplerCube cubeTex;\nuniform sampler2D maskTex;\n\n\n"
"void VertexShaderMain()\n{\n\n\ndiffuse=gl_Color*gl_LightSource[0].diffuse;\n"
"ambient=gl_Color*(gl_LightSource[0].ambient+gl_LightModel.ambient);\n"
"specular=gl_FrontMaterial.specular*gl_LightSource[0].specular;\n\n\n"
"gl_TexCoord[0]=gl_MultiTexCoord0;\ngl_Position=ftransform();\n\n\n\n"
"vec3 n=normalize(normal.xyz);\nvec3 t=normalize(tangent);\n"
"vec3 b=cross(n,t)*normal.w;\n"
"mat3 tbn=transpose(mat3(gl_ModelViewMatrix)*mat3(t,b,n));\n\n\n\n"
"vec3 eyeVertexPos=(gl_ModelViewMatrix*gl_Vertex).xyz;\n"
"vec3 eyeLightPos=gl_LightSource[0].position.xyz;\n"
"tangentLightDir=normalize(tbn*(eyeLightPos-eyeVertexPos));\n"
"tangentEye=normalize(tbn*-eyeVertexPos);\n\n#ifdef NEEDS_TANGENT_TO_WORLD\n\n"
"tangentToWorld=mat3(t,b,n);\n#endif\n}\n\n\n#if DIFFUSE\n"
"vec4 GetMaterialDiffuseColor(vec2 TexCoord)\n{\n"
"return texture2D(diffTex,TexCoord);\n}\n#endif\n\n"
"vec3 GetMaterialNormal(vec2 TexCoord)\n{\n#if 0\nreturn vec3(0.0,0.0,1.0);\n"
"#else\nreturn %s;\n#endif\n}\n\nvec3 GetMaterialSpecularColor(vec2 TexCoord)\n"
"{\n#ifndef SHOW_BUMP\nreturn %s;\n#else\nreturn vec3(1.0);\n#endif\n}\n\n"
"float GetMaterialSpecularPower(vec2 TexCoord)\n{\nreturn %s;\n}\n\n"
"float GetMaterialOpacity(vec2 TexCoord)\n{\nreturn %s;\n}\n\n#if EMISSIVE\n"
"vec3 GetMaterialEmissive(vec2 TexCoord)\n{\nreturn %s;\n}\n#endif\n\n"
"vec3 GetMaterialCubemap(vec3 TexCoord)\n{\nreturn %s;\n}\n\n"
"float GetCubemapMask(vec2 TexCoord)\n{\nreturn %s;\n}\n\n\n"
"void PixelShaderMain()\n{\nvec2 TexCoord=gl_TexCoord[0].st;\n\n"
"vec3 normal=GetMaterialNormal(TexCoord);\n%s\nnormal=normalize(normal);\n"
"vec3 nLightDir=normalize(tangentLightDir);\nvec3 nEye=normalize(tangentEye);\n"
"\nfloat NdotL=max(dot(normal,nLightDir),0.0);\n"
"vec4 color=ambient+diffuse*NdotL;\n\n#if DIFFUSE\n"
"vec4 diffuse=GetMaterialDiffuseColor(TexCoord);\ncolor*=diffuse;\n#endif\n\n"
"#ifdef SHOW_BUMP\ncolor=vec4(0.1,0.1,0.1,1.0);\n#endif\n\n#ifdef SPECULAR\n\n\n"
"\nvec3 halfVector=nLightDir+nEye;\nvec3 halfV=normalize(halfVector);\n"
"float NdotHV=max(dot(normal,halfV),0.0);\n"
"color.rgb+=pow(NdotHV,GetMaterialSpecularPower(TexCoord))*GetMaterialSpecularColor(TexCoord);\n"
"#endif\n\n#if CUBE && !DIFFUSE\ncolor=vec4(0.0,0.0,0.0,1.0);\n#endif\n\n"
"#if CUBE\nvec3 reflectVec=tangentToWorld*reflect(nEye,normal);\n"
"vec3 reflectColor=GetMaterialCubemap(-reflectVec);\n"
"color.rgb+=reflectColor*GetCubemapMask(TexCoord);\n#endif\n\n#if EMISSIVE\n"
"color.rgb+=GetMaterialEmissive(TexCoord);\n#endif\n\n"
"color.a=GetMaterialOpacity(TexCoord);\n\n\n\n\n\n#ifdef NORMALMAP\n"
"color.rgb=pow(dot(normal,nEye),3.5)*vec3(1.0);\n#endif\n#ifdef WORLDNORMAL\n"
"color.rgb=tangentToWorld*normal*0.5+0.5;\n#endif\n\ngl_FragColor=color;\n}\n";

